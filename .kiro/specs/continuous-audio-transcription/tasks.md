# 実装タスク: 24時間連続音声文字起こしシステム

本ドキュメントは、要件1-9（フェーズ1）の実装タスクを定義します。要件10（話者識別）はフェーズ2の将来機能として除外します。

## タスク実行の前提条件

- Node.js 18+ LTS がインストール済み
- TypeScript 5.x がインストール済み
- FFmpeg がインストール済み（`brew install ffmpeg`）
- BlackHole 2ch がインストール済み
- LAN内にCUDAサーバー（Windows RTX 3090 + Python環境）が利用可能
- pm2 がグローバルインストール済み（`npm install -g pm2`）

## 実装順序の原則

本タスクリストは**TDD（テスト駆動開発）**の原則に従い、以下の順序で進めます：

1. **テストファーストアプローチ**: 各機能の実装前に、その機能を検証するテストを作成
2. **段階的統合**: 小さな単位で実装し、早期に統合して動作確認
3. **継続的検証**: 各タスク完了時に既存テストがすべてパスすることを確認

---

## フェーズ1: 基盤構築とプロジェクト初期化

- [ ] 1. プロジェクト基盤とTypeScript環境のセットアップ
- [x] 1.1 Node.jsプロジェクトの初期化と開発環境構築
  - package.jsonを作成し、プロジェクトメタデータを定義
  - TypeScriptをインストールし、tsconfig.jsonで厳格な型チェックを有効化
  - ESLintとPrettierでコード品質基準を設定
  - Jestをテストランナーとして設定（ts-jestでTypeScriptサポート）
  - _Requirements: 全要件の基盤_

- [x] 1.2 設定管理システムの実装
  - デフォルト設定値を定義（音声デバイス名、サンプリングレート、CUDAサーバーURL等）
  - 設定ファイル（config.json）の読み込み機能を実装
  - 設定ファイルが存在しない場合、デフォルト設定で自動生成
  - 環境変数による設定上書き機能（WEBHOOK_URL等）
  - 設定検証ロジック（必須フィールドチェック、型検証）
  - 単体テスト: 有効な設定、無効な設定、デフォルト生成のテストケース
  - _Requirements: 9.5, 9.6, 9.7_

- [x] 1.3 ログ出力とエラーハンドリング基盤の構築
  - ログレベル（ERROR, WARN, INFO, DEBUG）を定義
  - ログフォーマット（タイムスタンプ、レベル、コンポーネント名、メッセージ）を実装
  - ファイル出力とコンソール出力の切り替え機能
  - エラー型定義（AudioCaptureError, ProcessError, FileError等）
  - Result型パターンの実装（成功/失敗を明示的に扱う）
  - 単体テスト: ログ出力の検証、エラー型の正しいハンドリング
  - _Requirements: 全要件（エラーハンドリング）_

- [x] 1.4 ファイルシステム管理の基盤実装
  - ディレクトリ構造（~/transcriptions/YYYY-MM-DD/raw/, hourly/）の作成機能
  - ファイルパーミッション設定（600/700）の自動適用
  - ディスク空き容量チェック機能
  - ファイルローテーション用のユーティリティ関数（日付計算、ファイル検索）
  - 単体テスト: ディレクトリ作成、パーミッション検証、容量チェック
  - _Requirements: 4.1, 4.8_

---

## フェーズ2: CUDAサーバー実装（Python/FastAPI）

- [ ] 2. CUDAサーバーのHTTP API実装
- [x] 2.1 FastAPIプロジェクトの初期化
  - FastAPIとuvicornをインストール
  - プロジェクト構造を作成（main.py, routers/, services/）
  - CORSミドルウェアを設定（LAN内アクセス許可）
  - ヘルスチェックエンドポイント（GET /health）を実装
  - サーバー起動スクリプトとタイムアウト設定（--timeout-keep-alive 70）
  - _Requirements: 3.1, 8.7_

- [x] 2.2 WhisperXによる文字起こし機能の実装
  - WhisperXとCUDA依存関係をインストール（requirements.txt）
  - WhisperXモデル（large-v2またはmedium）をロードする起動時処理
  - 音声ファイルを受信し、WhisperXで文字起こしを実行する処理
  - word-level alignmentを適用し、高精度タイムスタンプを生成
  - GPU VRAMが不足した場合のbatch_size自動調整ロジック
  - エラーハンドリング（音声形式不正、処理タイムアウト等）
  - 単体テスト: モック音声ファイルでの文字起こし、エラーケース
  - _Requirements: 3.1, 3.2, 3.3_

- [x] 2.3 pyannote.audioによる話者分離機能の実装
  - pyannote.audioとHugging Face Hubをインストール
  - Hugging Face Access Tokenを環境変数から読み込み
  - pyannote.audio pipelineをロード（speaker-diarization-3.1）
  - 音声ファイルから話者分離を実行し、Annotationオブジェクトを取得
  - 文字起こしセグメントに話者ラベル（Speaker_00, Speaker_01等）を付与
  - 話者ラベル付与ロジック（セグメント中間時刻での話者マッピング）
  - 短い音声（3秒未満）での話者分離失敗時のフォールバック処理
  - 単体テスト: モック音声での話者分離、ラベル付与の正確性
  - _Requirements: 8.1, 8.2, 8.3, 8.4_

- [x] 2.4 文字起こしAPIエンドポイントの実装
  - POST /transcribe エンドポイントを実装
  - multipart/form-dataで音声ファイルを受信
  - 一時ファイルとして保存し、処理完了後に削除
  - WhisperXとpyannote.audioを順次実行
  - レスポンスJSON（segments配列、language、duration）を返却
  - タイムアウト処理（60秒以内に完了、超過時408エラー）
  - エラーレスポンス（400, 408, 500, 503）の適切な返却
  - 統合テスト: 実音声ファイルでのE2E処理、各種エラーケース
  - _Requirements: 3.1, 3.4, 3.5, 3.6, 8.5_

- [x] 2.5 デプロイメント管理APIの実装
  - POST /deploy エンドポイントを実装（git pull + 依存関係更新 + サービス再起動）
  - POST /restart エンドポイントを実装（サービス再起動のみ）
  - GET /status エンドポイントを実装（pm2からサービス状態を取得）
  - GET /logs エンドポイントを実装（pm2ログの取得）
  - GET /version エンドポイントを実装（現在のGitコミット情報を返却）
  - GET /health エンドポイントを実装（デプロイメントサーバーのヘルスチェック）
  - subprocessでgit、pip、pm2コマンドを実行
  - エラーハンドリング（Git pull失敗、pip install失敗、pm2 restart失敗）
  - 単体テスト: 各エンドポイントの正常/エラーケース、Gitコマンド実行
  - _Requirements: 開発ワークフロー効率化（追加機能）_

---

## フェーズ3: 音声キャプチャとバッファリング（Mac Client）

- [ ] 3. 音声キャプチャとバッファリング機能の実装
- [x] 3.1 FFmpegを使用した音声ストリーミングキャプチャ
  - FFmpegの子プロセスを起動し、BlackHoleデバイスから音声をストリーミング
  - 音声フォーマット変換（16kHz、モノラル、WAV）をFFmpegで実行
  - stdoutからストリーミングデータを読み取り、30秒バッファに蓄積
  - FFmpegプロセスのエラーハンドリング（デバイス未検出、権限エラー等）
  - FFmpegクラッシュ時の自動再起動ロジック（10秒待機、最大3回リトライ）
  - 単体テスト: モック音声デバイスでのキャプチャ、エラーケース
  - _Requirements: 1.1, 1.2, 1.3, 1.6, 1.7_

- [x] 3.2 30秒バッファ管理機能の実装
  - 音声データを30秒間メモリバッファに蓄積
  - バッファが満たされたら一時ファイル（/tmp/transcription-buffers/）に保存
  - バッファ保存後、メモリを即座に解放（null化）してメモリリークを防止
  - バッファファイルのタイムスタンプ管理（ファイル名: HH-MM-SS-mmm.wav）
  - 一時ファイルのクリーンアップ処理（処理完了後即削除）
  - 単体テスト: バッファ蓄積、ファイル保存、メモリ解放の検証
  - _Requirements: 1.4, 1.5_

- [x] 3.3 音声レベルベースの無音検出（VAD）実装
  - 音声バッファの音声レベルを分析（dB計算）
  - 閾値（-40dB）と継続時間（10秒以上）で無音判定
  - VAD結果（isVoiceDetected、averageLevel、silenceDuration）を返却
  - 5分以上無音が続いた場合、強制的に音声検出フラグを返す（接続確認）
  - スキップされたバッファのログ記録
  - 単体テスト: 無音音声、通常音声、境界値のテストケース
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5_

---

## フェーズ4: CUDAサーバー連携とHTTP通信

- [x] 4. CUDAサーバーとの通信機能の実装
- [x] 4.1 HTTP クライアントの実装（axios使用）
  - axiosをインストールし、HTTP POSTリクエストを実装
  - multipart/form-dataで音声ファイルを送信
  - タイムアウト設定（60秒）とリトライロジック（3回、指数バックオフ）
  - CUDAサーバーからのレスポンス（TranscriptionResponse）をパース
  - HTTPエラーハンドリング（400, 408, 500, 503）
  - ヘルスチェックエンドポイント（GET /health）の実行
  - 単体テスト: モックサーバーでの正常/エラーレスポンス検証
  - _Requirements: 3.1, 3.2, 3.4, 8.7_

- [x] 4.2 バッファ処理とCUDA連携の統合
  - VAD判定結果に基づき、音声検出時のみCUDAサーバーにリクエスト送信
  - 無音の場合はスキップし、ログに記録
  - CUDAサーバーからの文字起こし結果を取得
  - サーバータイムアウト時の処理（該当バッファをスキップ、ログ記録）
  - 連続3回失敗時のアラート送信
  - 統合テスト: 音声キャプチャ → VAD → CUDA通信の完全フロー
  - _Requirements: 3.3, 3.4, 3.7_

---

## フェーズ5: ファイル管理とデータ永続化

- [ ] 5. 文字起こし結果の保存と集約機能の実装
- [x] 5.1 JSONL形式での文字起こし結果保存
  - TranscriptionResponseをJSONL形式に変換（1行1セグメント）
  - タイムスタンプ、音声ファイルパス、セグメント情報、話者ラベルを含める
  - ~/transcriptions/YYYY-MM-DD/raw/HH-MM-SS.jsonlに追記
  - ファイルハンドルの即座クローズ（メモリリーク防止）
  - ディスク容量不足時のエラーハンドリングと古いファイル削除
  - 単体テスト: JSONL書き込み、フォーマット検証、容量不足エラー
  - _Requirements: 3.5, 3.6, 4.1, 8.5, 8.6_

- [x] 5.2 hourly集約ファイルの生成
  - 1時間ごとに~/transcriptions/YYYY-MM-DD/hourly/HH.txtを生成
  - raw/ディレクトリから該当時間帯のJSONLファイルを読み込み
  - 時系列順にソートし、`[HH:MM:SS] [Speaker_XX] テキスト`形式で出力
  - 定期実行（cron風スケジューラ）または1時間経過時トリガー
  - 単体テスト: 複数JSONLファイルの集約、ソート順検証
  - _Requirements: 4.2, 4.3, 8.6_

- [x] 5.3 daily集約ファイルの生成
  - 日付が変わったタイミングで~/transcriptions/YYYY-MM-DD/daily.txtを生成
  - 前日の全hourlyファイルを時系列で結合
  - ヘッダー（`=== YYYY-MM-DD 全発言記録 ===`）を追加
  - 単体テスト: hourlyファイルの結合、フォーマット検証
  - _Requirements: 4.4_

- [x] 5.4 ファイルローテーションと自動削除の実装
  - 7日以上経過したraw/ファイルを自動削除
  - 30日以上経過したhourly/ファイルを自動削除
  - daily.txtは永続保存（削除しない）
  - 3日以上経過したファイルをgzip圧縮
  - 定期実行（1日1回）でローテーション処理を実行
  - 単体テスト: 日付計算、ファイル削除、圧縮処理
  - _Requirements: 4.5, 4.6, 4.7_

---

## フェーズ6: システム監視とヘルスチェック

- [x] 6. システムリソース監視とアラート機能の実装
- [x] 6.1 メモリ・CPU使用率の監視
  - Node.jsのprocess.memoryUsage()でメモリ使用量を取得
  - osモジュールでCPU使用率を計算
  - 1分ごとに監視を実行し、メトリクスを記録
  - メモリが2GBを超えた場合、警告ログを出力
  - CPU使用率が50%を5分連続で超えた場合、警告ログを出力
  - 単体テスト: メトリクス取得、閾値判定
  - _Requirements: 6.1, 6.2, 6.3, 6.4_

- [x] 6.2 最終文字起こし時刻の追跡
  - 最終文字起こし成功時刻をメモリに保持
  - 5分以上経過し、かつ音声入力が継続中の場合、異常ログを出力
  - 単体テスト: 時刻追跡、異常検出ロジック
  - _Requirements: 6.5, 6.6_

- [x] 6.3 エラー発生回数のカウントとアラート
  - 1時間ごとにエラー発生回数をカウント
  - 10回を超えた場合、緊急アラートを送信
  - エラーカウントは1時間ごとにリセット
  - 単体テスト: カウンター、リセットロジック
  - _Requirements: 6.7, 6.8_

- [x] 6.4 Webhook通知機能の実装
  - 設定ファイルからWebhook URLを読み込み（環境変数優先）
  - 異常検出時にSlack/Discord形式のJSON通知を送信
  - 通知内容（エラー種別、メトリクス値、タイムスタンプ）を含める
  - 送信失敗時のログ記録（リトライはしない）
  - 単体テスト: モックWebhookエンドポイントへの通知送信
  - _Requirements: 6.2, 6.6, 6.8, 7.1_

---

## フェーズ7: 通知とレポート機能

- [x] 7. 日次・週次レポート生成と通知
- [x] 7.1 日次レポートの生成
  - 1日の文字起こし文字数を集計（daily.txtから計算）
  - システム稼働時間を記録
  - エラー発生回数を集計
  - レポートをテキスト形式で生成
  - 単体テスト: レポート生成、文字数集計
  - _Requirements: 7.2_

- [x] 7.2 日次レポートのWebhook送信
  - 日次レポートをWebhook経由で管理者に送信
  - 送信タイミング（日付が変わった直後）
  - 単体テスト: レポート送信、Webhookペイロード検証
  - _Requirements: 7.3_

- [x] 7.3 週次レポートの生成と送信
  - ストレージ使用量を計算（~/transcriptions/全ファイルサイズ）
  - 平均CPU/メモリ使用率を集計（過去7日間のメトリクス）
  - エラー統計を集計
  - 週次レポートをWebhook経由で送信
  - 単体テスト: レポート生成、統計計算
  - _Requirements: 7.4, 7.5_

---

## フェーズ8: プロセス管理と自動復旧

- [x] 8. pm2によるプロセス管理と自動復旧の実装
- [x] 8.1 pm2エコシステムファイルの作成
  - ecosystem.config.jsを作成
  - アプリケーション名、スクリプトパス、環境変数を定義
  - メモリ上限（--max-memory-restart 2048M）を設定
  - ログファイルパス（~/transcriptions/logs/）を指定
  - クラスタモード不使用（単一プロセス）
  - _Requirements: 5.6_

- [x] 8.2 予防的プロセス再起動の実装
  - 1時間ごとに現在のバッファを保存
  - pm2のgraceful reloadを実行（または自前でプロセス再起動）
  - 再起動完了後、音声キャプチャを自動再開
  - 再起動ログを記録
  - 統合テスト: 再起動前後の状態保持、音声キャプチャ再開
  - _Requirements: 5.1, 5.2, 5.3_

- [x] 8.3 予期せぬクラッシュ時の自動復旧
  - pm2の自動再起動機能を利用
  - 再起動時に前回の処理状態を復元（未処理バッファがあれば処理継続）
  - 再起動回数が多い場合のアラート（1時間に3回以上）
  - 統合テスト: クラッシュシミュレーション、自動復旧検証
  - _Requirements: 5.4, 5.5_

---

## フェーズ9: CLI実装とユーザーインターフェース

- [x] 9. CLIコマンドの実装
- [x] 9.1 CLI フレームワークのセットアップ
  - commanderライブラリをインストール
  - CLIエントリーポイント（bin/transcribe.ts）を作成
  - サブコマンド構造（start, stop, status, logs）を定義
  - package.jsonにbinフィールドを追加（グローバルコマンド化）
  - _Requirements: 9.1, 9.2, 9.3, 9.4_

- [x] 9.2 `transcribe start` コマンドの実装
  - pm2を使用してバックグラウンドでデーモンプロセスを起動
  - 起動成功メッセージ（PID表示）を出力
  - 既に起動中の場合のエラーメッセージ
  - 単体テスト: pm2起動、重複起動エラー
  - _Requirements: 9.1_

- [x] 9.3 `transcribe stop` コマンドの実装
  - 現在のバッファを安全に保存
  - pm2でプロセスを停止
  - 停止成功メッセージを出力
  - プロセスが起動していない場合のエラーメッセージ
  - 単体テスト: 安全な停止、バッファ保存検証
  - _Requirements: 9.2_

- [x] 9.4 `transcribe status` コマンドの実装
  - pm2からプロセス状態（起動中/停止中、PID、稼働時間）を取得
  - HealthMonitorからメトリクス（メモリ使用量、最終文字起こし時刻）を取得
  - 設定ファイルから話者分離の有効/無効を表示
  - フォーマット済み出力（表形式またはJSON）
  - 単体テスト: 状態取得、出力フォーマット
  - _Requirements: 9.3_

- [x] 9.5 `transcribe logs` コマンドの実装
  - pm2のログファイルから直近100行を読み取り
  - リアルタイム表示（tail -f風）のオプション
  - ログレベルフィルター（--level=ERROR等）のサポート
  - 単体テスト: ログ読み取り、フィルタリング
  - _Requirements: 9.4_

---

## フェーズ10: 統合テストとE2Eテスト

- [ ] 10. システム全体の統合テストとE2Eテスト
- [ ] 10.1 音声キャプチャから文字起こしまでのE2Eテスト
  - テスト音声ファイル（3分、複数話者）を準備
  - BlackHoleデバイスに音声を再生（またはモック）
  - `transcribe start`でシステム起動
  - 3分後、JSONLファイルが生成されていることを確認
  - 話者ラベル（Speaker_00、Speaker_01）が含まれることを確認
  - `transcribe stop`でシステム停止
  - E2Eテスト: 完全フロー検証
  - _Requirements: 1.1-1.7, 2.1-2.5, 3.1-3.7, 8.1-8.8_

- [ ] 10.2 CUDAサーバー障害時のフォールバックテスト
  - CUDAサーバーを停止（またはモック障害）
  - 音声キャプチャを継続
  - フォールバック警告がログに出力されることを確認
  - config.jsonで`fallbackToLocal: true`の場合、ローカル処理が実行されることを確認（将来実装）
  - `fallbackToLocal: false`の場合、バッファがスキップされることを確認
  - E2Eテスト: 障害シナリオ検証
  - _Requirements: 3.3, 3.7_

- [ ] 10.3 24時間連続稼働シミュレーション（短縮版: 1時間）
  - `transcribe start`でシステム起動
  - 1時間の間、5分ごとにテスト音声を再生
  - 1時間後、メモリ使用量が2GB以下であることを確認
  - hourlyファイルが生成されていることを確認
  - ログにメモリリークやクラッシュがないことを確認
  - プロセス再起動（1時間ごと）が正常に実行されることを確認
  - E2Eテスト: 長時間稼働シナリオ
  - _Requirements: 5.1-5.6, 6.1-6.8_

- [ ] 10.4 hourly/daily集約機能のE2Eテスト
  - 複数の時間帯にまたがるJSONLファイルを事前生成
  - hourly集約処理を実行し、ファイルが正しく生成されることを確認
  - daily集約処理を実行し、全hourlyファイルが結合されることを確認
  - ファイルローテーション処理を実行し、古いファイルが削除されることを確認
  - E2Eテスト: ファイル管理シナリオ
  - _Requirements: 4.2-4.7_

- [ ] 10.5 CLIコマンドのE2Eテスト
  - `transcribe start` → システム起動確認
  - `transcribe status` → 正しい状態表示確認
  - `transcribe logs` → ログ表示確認
  - `transcribe stop` → 安全な停止確認
  - 各コマンドのエラーケース（既に起動中、停止中等）を検証
  - E2Eテスト: CLI操作シナリオ
  - _Requirements: 9.1-9.7_

---

## フェーズ11: ドキュメント整備とリリース準備

- [x] 11. プロジェクトドキュメントとリリース準備
- [x] 11.1 README.mdの作成
  - プロジェクト概要と主要機能
  - インストール手順（Node.js、FFmpeg、BlackHole、pm2）
  - CUDAサーバーのセットアップ手順（別ドキュメントへのリンク）
  - 設定ファイル（config.json）のリファレンス
  - CLI使用方法（start, stop, status, logs）
  - トラブルシューティングガイド
  - _Requirements: 全要件（ユーザー向けドキュメント）_

- [x] 11.2 CUDAサーバーセットアップガイドの作成
  - Python環境セットアップ手順（venv、CUDA、cuDNN）
  - WhisperXとpyannote.audioのインストール手順
  - Hugging Face Access Tokenの取得と設定
  - FastAPIサーバーの起動方法
  - ポート開放とファイアウォール設定
  - _Requirements: 3.1, 8.1, 8.7_

- [x] 11.3 テストカバレッジレポートの生成
  - Jestでカバレッジレポート（--coverage）を生成
  - カバレッジ80%以上を目標に、不足部分を補完
  - HTMLレポートを生成し、コードレビューで使用
  - _Requirements: 全要件（品質保証）_

---

## 要件カバレッジマッピング

### 要件1: 音声キャプチャとバッファリング
- タスク 3.1: FFmpeg音声ストリーミング（1.1, 1.2, 1.3, 1.6, 1.7）
- タスク 3.2: 30秒バッファ管理（1.4, 1.5）

### 要件2: 無音検出と処理最適化
- タスク 3.3: VAD実装（2.1, 2.2, 2.3, 2.4, 2.5）

### 要件3: 文字起こし処理（CUDA）
- タスク 2.2: WhisperX実装（3.1, 3.2, 3.3）
- タスク 2.4: APIエンドポイント（3.1, 3.4, 3.5, 3.6）
- タスク 4.1: HTTPクライアント（3.1, 3.2, 3.4）
- タスク 4.2: CUDA連携統合（3.3, 3.4, 3.7）

### 要件4: ファイル管理とローテーション
- タスク 1.4: ファイルシステム基盤（4.1, 4.8）
- タスク 5.1: JSONL保存（4.1）
- タスク 5.2: hourly集約（4.2, 4.3）
- タスク 5.3: daily集約（4.4）
- タスク 5.4: ファイルローテーション（4.5, 4.6, 4.7, 4.8）

### 要件5: プロセス管理と自動復旧
- タスク 8.1: pm2エコシステム（5.6）
- タスク 8.2: 予防的再起動（5.1, 5.2, 5.3）
- タスク 8.3: 自動復旧（5.4, 5.5）

### 要件6: システム監視とヘルスチェック
- タスク 6.1: メモリ・CPU監視（6.1, 6.2, 6.3, 6.4）
- タスク 6.2: 最終文字起こし追跡（6.5, 6.6）
- タスク 6.3: エラーカウント（6.7, 6.8）
- タスク 6.4: Webhook通知（6.2, 6.6, 6.8）

### 要件7: 通知と日次レポート
- タスク 6.4: Webhook通知（7.1）
- タスク 7.1: 日次レポート生成（7.2）
- タスク 7.2: 日次レポート送信（7.3）
- タスク 7.3: 週次レポート（7.4, 7.5）

### 要件8: 話者分離
- タスク 2.3: pyannote.audio実装（8.1, 8.2, 8.3, 8.4）
- タスク 2.4: APIエンドポイント（8.5）
- タスク 5.1: JSONL保存（8.5, 8.6）
- タスク 5.2: hourly集約（8.6）
- タスク 4.1: ヘルスチェック（8.7）
- タスク 10.2: フォールバックテスト（8.8）

### 要件9: CLI操作と設定管理
- タスク 1.2: 設定管理（9.5, 9.6, 9.7）
- タスク 9.1: CLIセットアップ（9.1, 9.2, 9.3, 9.4）
- タスク 9.2: start コマンド（9.1）
- タスク 9.3: stop コマンド（9.2）
- タスク 9.4: status コマンド（9.3）
- タスク 9.5: logs コマンド（9.4）

### 要件10: 話者識別（フェーズ2、本タスクリストでは除外）
- 将来実装予定

---

## 実装完了の定義

各タスクは以下の条件を満たした時点で完了とみなします：

1. **コード実装**: 機能が正しく動作する実装コードが完成
2. **単体テスト**: 該当機能のテストがすべてパス（カバレッジ80%以上）
3. **統合テスト**: 関連する他のコンポーネントとの連携が正常動作
4. **コードレビュー**: ESLintとPrettierのチェックがパス
5. **ドキュメント**: 必要に応じてコメントやREADMEを更新

---

## 次のステップ

タスクリストの承認後、以下のコマンドで実装を開始してください：

```bash
# すべてのタスクを順次実行
/kiro:spec-impl continuous-audio-transcription

# 特定のタスクのみ実行
/kiro:spec-impl continuous-audio-transcription 1.1

# 複数タスクを実行
/kiro:spec-impl continuous-audio-transcription 1,2,3
```

**実装のヒント**:
- TDD原則に従い、テストファーストで進める
- 各タスク完了後、すべてのテストを実行して回帰を確認
- 早期に統合し、問題を早期発見
- コンテキストが長くなった場合、`/clear`で会話をクリアしてから継続
